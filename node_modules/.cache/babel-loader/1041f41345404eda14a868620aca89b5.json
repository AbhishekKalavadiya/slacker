{"ast":null,"code":"\"use strict\";\n\nmodule.exports = Method; // extends ReflectionObject\n\nvar ReflectionObject = require(\"./object\");\n\n((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = \"Method\";\n\nvar util = require(\"./util\");\n/**\n * Constructs a new service method instance.\n * @classdesc Reflected service method.\n * @extends ReflectionObject\n * @constructor\n * @param {string} name Method name\n * @param {string|undefined} type Method type, usually `\"rpc\"`\n * @param {string} requestType Request message type\n * @param {string} responseType Response message type\n * @param {boolean|Object.<string,*>} [requestStream] Whether the request is streamed\n * @param {boolean|Object.<string,*>} [responseStream] Whether the response is streamed\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] The comment for this method\n */\n\n\nfunction Method(name, type, requestType, responseType, requestStream, responseStream, options, comment) {\n  /* istanbul ignore next */\n  if (util.isObject(requestStream)) {\n    options = requestStream;\n    requestStream = responseStream = undefined;\n  } else if (util.isObject(responseStream)) {\n    options = responseStream;\n    responseStream = undefined;\n  }\n  /* istanbul ignore if */\n\n\n  if (!(type === undefined || util.isString(type))) throw TypeError(\"type must be a string\");\n  /* istanbul ignore if */\n\n  if (!util.isString(requestType)) throw TypeError(\"requestType must be a string\");\n  /* istanbul ignore if */\n\n  if (!util.isString(responseType)) throw TypeError(\"responseType must be a string\");\n  ReflectionObject.call(this, name, options);\n  /**\n   * Method type.\n   * @type {string}\n   */\n\n  this.type = type || \"rpc\"; // toJSON\n\n  /**\n   * Request type.\n   * @type {string}\n   */\n\n  this.requestType = requestType; // toJSON, marker\n\n  /**\n   * Whether requests are streamed or not.\n   * @type {boolean|undefined}\n   */\n\n  this.requestStream = requestStream ? true : undefined; // toJSON\n\n  /**\n   * Response type.\n   * @type {string}\n   */\n\n  this.responseType = responseType; // toJSON\n\n  /**\n   * Whether responses are streamed or not.\n   * @type {boolean|undefined}\n   */\n\n  this.responseStream = responseStream ? true : undefined; // toJSON\n\n  /**\n   * Resolved request type.\n   * @type {Type|null}\n   */\n\n  this.resolvedRequestType = null;\n  /**\n   * Resolved response type.\n   * @type {Type|null}\n   */\n\n  this.resolvedResponseType = null;\n  /**\n   * Comment for this method\n   * @type {string|null}\n   */\n\n  this.comment = comment;\n}\n/**\n * Method descriptor.\n * @interface IMethod\n * @property {string} [type=\"rpc\"] Method type\n * @property {string} requestType Request type\n * @property {string} responseType Response type\n * @property {boolean} [requestStream=false] Whether requests are streamed\n * @property {boolean} [responseStream=false] Whether responses are streamed\n * @property {Object.<string,*>} [options] Method options\n */\n\n/**\n * Constructs a method from a method descriptor.\n * @param {string} name Method name\n * @param {IMethod} json Method descriptor\n * @returns {Method} Created method\n * @throws {TypeError} If arguments are invalid\n */\n\n\nMethod.fromJSON = function fromJSON(name, json) {\n  return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment);\n};\n/**\n * Converts this method to a method descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IMethod} Method descriptor\n */\n\n\nMethod.prototype.toJSON = function toJSON(toJSONOptions) {\n  var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n  return util.toObject([\"type\", this.type !== \"rpc\" &&\n  /* istanbul ignore next */\n  this.type || undefined, \"requestType\", this.requestType, \"requestStream\", this.requestStream, \"responseType\", this.responseType, \"responseStream\", this.responseStream, \"options\", this.options, \"comment\", keepComments ? this.comment : undefined]);\n};\n/**\n * @override\n */\n\n\nMethod.prototype.resolve = function resolve() {\n  /* istanbul ignore if */\n  if (this.resolved) return this;\n  this.resolvedRequestType = this.parent.lookupType(this.requestType);\n  this.resolvedResponseType = this.parent.lookupType(this.responseType);\n  return ReflectionObject.prototype.resolve.call(this);\n};","map":{"version":3,"sources":["C:/React/slacker/node_modules/protobufjs/src/method.js"],"names":["module","exports","Method","ReflectionObject","require","prototype","Object","create","constructor","className","util","name","type","requestType","responseType","requestStream","responseStream","options","comment","isObject","undefined","isString","TypeError","call","resolvedRequestType","resolvedResponseType","fromJSON","json","toJSON","toJSONOptions","keepComments","Boolean","toObject","resolve","resolved","parent","lookupType"],"mappings":"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","sourcesContent":["\"use strict\";\nmodule.exports = Method;\n\n// extends ReflectionObject\nvar ReflectionObject = require(\"./object\");\n((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = \"Method\";\n\nvar util = require(\"./util\");\n\n/**\n * Constructs a new service method instance.\n * @classdesc Reflected service method.\n * @extends ReflectionObject\n * @constructor\n * @param {string} name Method name\n * @param {string|undefined} type Method type, usually `\"rpc\"`\n * @param {string} requestType Request message type\n * @param {string} responseType Response message type\n * @param {boolean|Object.<string,*>} [requestStream] Whether the request is streamed\n * @param {boolean|Object.<string,*>} [responseStream] Whether the response is streamed\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] The comment for this method\n */\nfunction Method(name, type, requestType, responseType, requestStream, responseStream, options, comment) {\n\n    /* istanbul ignore next */\n    if (util.isObject(requestStream)) {\n        options = requestStream;\n        requestStream = responseStream = undefined;\n    } else if (util.isObject(responseStream)) {\n        options = responseStream;\n        responseStream = undefined;\n    }\n\n    /* istanbul ignore if */\n    if (!(type === undefined || util.isString(type)))\n        throw TypeError(\"type must be a string\");\n\n    /* istanbul ignore if */\n    if (!util.isString(requestType))\n        throw TypeError(\"requestType must be a string\");\n\n    /* istanbul ignore if */\n    if (!util.isString(responseType))\n        throw TypeError(\"responseType must be a string\");\n\n    ReflectionObject.call(this, name, options);\n\n    /**\n     * Method type.\n     * @type {string}\n     */\n    this.type = type || \"rpc\"; // toJSON\n\n    /**\n     * Request type.\n     * @type {string}\n     */\n    this.requestType = requestType; // toJSON, marker\n\n    /**\n     * Whether requests are streamed or not.\n     * @type {boolean|undefined}\n     */\n    this.requestStream = requestStream ? true : undefined; // toJSON\n\n    /**\n     * Response type.\n     * @type {string}\n     */\n    this.responseType = responseType; // toJSON\n\n    /**\n     * Whether responses are streamed or not.\n     * @type {boolean|undefined}\n     */\n    this.responseStream = responseStream ? true : undefined; // toJSON\n\n    /**\n     * Resolved request type.\n     * @type {Type|null}\n     */\n    this.resolvedRequestType = null;\n\n    /**\n     * Resolved response type.\n     * @type {Type|null}\n     */\n    this.resolvedResponseType = null;\n\n    /**\n     * Comment for this method\n     * @type {string|null}\n     */\n    this.comment = comment;\n}\n\n/**\n * Method descriptor.\n * @interface IMethod\n * @property {string} [type=\"rpc\"] Method type\n * @property {string} requestType Request type\n * @property {string} responseType Response type\n * @property {boolean} [requestStream=false] Whether requests are streamed\n * @property {boolean} [responseStream=false] Whether responses are streamed\n * @property {Object.<string,*>} [options] Method options\n */\n\n/**\n * Constructs a method from a method descriptor.\n * @param {string} name Method name\n * @param {IMethod} json Method descriptor\n * @returns {Method} Created method\n * @throws {TypeError} If arguments are invalid\n */\nMethod.fromJSON = function fromJSON(name, json) {\n    return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment);\n};\n\n/**\n * Converts this method to a method descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IMethod} Method descriptor\n */\nMethod.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"type\"           , this.type !== \"rpc\" && /* istanbul ignore next */ this.type || undefined,\n        \"requestType\"    , this.requestType,\n        \"requestStream\"  , this.requestStream,\n        \"responseType\"   , this.responseType,\n        \"responseStream\" , this.responseStream,\n        \"options\"        , this.options,\n        \"comment\"        , keepComments ? this.comment : undefined\n    ]);\n};\n\n/**\n * @override\n */\nMethod.prototype.resolve = function resolve() {\n\n    /* istanbul ignore if */\n    if (this.resolved)\n        return this;\n\n    this.resolvedRequestType = this.parent.lookupType(this.requestType);\n    this.resolvedResponseType = this.parent.lookupType(this.responseType);\n\n    return ReflectionObject.prototype.resolve.call(this);\n};\n"]},"metadata":{},"sourceType":"script"}