{"ast":null,"code":"\"use strict\"; // Copyright 2020 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst document_1 = require(\"./document\");\n\nconst reference_1 = require(\"./reference\");\n\nconst timestamp_1 = require(\"./timestamp\");\n\nconst validate_1 = require(\"./validate\");\n\nconst BUNDLE_VERSION = 1;\n/**\n * Builds a Firestore data bundle with results from the given document and query snapshots.\n *\n * @private\n */\n\nclass BundleBuilder {\n  constructor(bundleId) {\n    this.bundleId = bundleId; // Resulting documents for the bundle, keyed by full document path.\n\n    this.documents = new Map(); // Named queries saved in the bundle, keyed by query name.\n\n    this.namedQueries = new Map(); // The latest read time among all bundled documents and queries.\n\n    this.latestReadTime = new timestamp_1.Timestamp(0, 0);\n  }\n  /**\n   * Adds a Firestore document snapshot or query snapshot to the bundle.\n   * Both the documents data and the query read time will be included in the bundle.\n   *\n   * @param {DocumentSnapshot | string} documentOrName A document snapshot to add or a name of a query.\n   * @param {Query=} querySnapshot A query snapshot to add to the bundle, if provided.\n   * @returns {BundleBuilder} This instance.\n   *\n   * @example\n   * const bundle = firestore.bundle('data-bundle');\n   * const docSnapshot = await firestore.doc('abc/123').get();\n   * const querySnapshot = await firestore.collection('coll').get();\n   *\n   * const bundleBuffer = bundle.add(docSnapshot); // Add a document\n   *                            .add('coll-query', querySnapshot) // Add a named query.\n   *                            .build()\n   * // Save `bundleBuffer` to CDN or stream it to clients.\n   */\n\n\n  add(documentOrName, querySnapshot) {\n    // eslint-disable-next-line prefer-rest-params\n    validate_1.validateMinNumberOfArguments('BundleBuilder.add', arguments, 1); // eslint-disable-next-line prefer-rest-params\n\n    validate_1.validateMaxNumberOfArguments('BundleBuilder.add', arguments, 2);\n\n    if (arguments.length === 1) {\n      validateDocumentSnapshot('documentOrName', documentOrName);\n      this.addBundledDocument(documentOrName);\n    } else {\n      validate_1.validateString('documentOrName', documentOrName);\n      validateQuerySnapshot('querySnapshot', querySnapshot);\n      this.addNamedQuery(documentOrName, querySnapshot);\n    }\n\n    return this;\n  }\n\n  addBundledDocument(snap) {\n    const docProto = snap.toDocumentProto();\n    this.documents.set(snap.id, {\n      document: snap.exists ? docProto : undefined,\n      metadata: {\n        name: docProto.name,\n        readTime: snap.readTime.toProto().timestampValue,\n        exists: snap.exists\n      }\n    });\n\n    if (snap.readTime > this.latestReadTime) {\n      this.latestReadTime = snap.readTime;\n    }\n  }\n\n  addNamedQuery(name, querySnap) {\n    if (this.namedQueries.has(name)) {\n      throw new Error(`Query name conflict: ${name} is already added.`);\n    }\n\n    this.namedQueries.set(name, {\n      name,\n      bundledQuery: querySnap.query._toBundledQuery(),\n      readTime: querySnap.readTime.toProto().timestampValue\n    });\n\n    for (const snap of querySnap.docs) {\n      this.addBundledDocument(snap);\n    }\n\n    if (querySnap.readTime > this.latestReadTime) {\n      this.latestReadTime = querySnap.readTime;\n    }\n  }\n  /**\n   * Converts a IBundleElement to a Buffer whose content is the length prefixed JSON representation\n   * of the element.\n   * @private\n   */\n\n\n  elementToLengthPrefixedBuffer(bundleElement) {\n    const buffer = Buffer.from(JSON.stringify(bundleElement), 'utf-8');\n    const lengthBuffer = Buffer.from(buffer.length.toString());\n    return Buffer.concat([lengthBuffer, buffer]);\n  }\n\n  build() {\n    let bundleBuffer = Buffer.alloc(0);\n\n    for (const namedQuery of this.namedQueries.values()) {\n      bundleBuffer = Buffer.concat([bundleBuffer, this.elementToLengthPrefixedBuffer({\n        namedQuery\n      })]);\n    }\n\n    for (const bundledDocument of this.documents.values()) {\n      const documentMetadata = bundledDocument.metadata;\n      bundleBuffer = Buffer.concat([bundleBuffer, this.elementToLengthPrefixedBuffer({\n        documentMetadata\n      })]); // Write to the bundle if document exists.\n\n      const document = bundledDocument.document;\n\n      if (document) {\n        bundleBuffer = Buffer.concat([bundleBuffer, this.elementToLengthPrefixedBuffer({\n          document\n        })]);\n      }\n    }\n\n    const metadata = {\n      id: this.bundleId,\n      createTime: this.latestReadTime.toProto().timestampValue,\n      version: BUNDLE_VERSION,\n      totalDocuments: this.documents.size,\n      totalBytes: bundleBuffer.length\n    }; // Prepends the metadata element to the bundleBuffer: `bundleBuffer` is the second argument to `Buffer.concat`.\n\n    bundleBuffer = Buffer.concat([this.elementToLengthPrefixedBuffer({\n      metadata\n    }), bundleBuffer]);\n    return bundleBuffer;\n  }\n\n}\n\nexports.BundleBuilder = BundleBuilder;\n/**\n * Convenient class to hold both the metadata and the actual content of a document to be bundled.\n * @private\n */\n\nclass BundledDocument {\n  constructor(metadata, document) {\n    this.metadata = metadata;\n    this.document = document;\n  }\n\n}\n/**\n * Validates that 'value' is DocumentSnapshot.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n */\n\n\nfunction validateDocumentSnapshot(arg, value) {\n  if (!(value instanceof document_1.DocumentSnapshot)) {\n    throw new Error(validate_1.invalidArgumentMessage(arg, 'DocumentSnapshot'));\n  }\n}\n/**\n * Validates that 'value' is QuerySnapshot.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n */\n\n\nfunction validateQuerySnapshot(arg, value) {\n  if (!(value instanceof reference_1.QuerySnapshot)) {\n    throw new Error(validate_1.invalidArgumentMessage(arg, 'QuerySnapshot'));\n  }\n}","map":{"version":3,"sources":["C:/React/slacker/node_modules/@google-cloud/firestore/build/src/bundle.js"],"names":["Object","defineProperty","exports","value","document_1","require","reference_1","timestamp_1","validate_1","BUNDLE_VERSION","BundleBuilder","constructor","bundleId","documents","Map","namedQueries","latestReadTime","Timestamp","add","documentOrName","querySnapshot","validateMinNumberOfArguments","arguments","validateMaxNumberOfArguments","length","validateDocumentSnapshot","addBundledDocument","validateString","validateQuerySnapshot","addNamedQuery","snap","docProto","toDocumentProto","set","id","document","exists","undefined","metadata","name","readTime","toProto","timestampValue","querySnap","has","Error","bundledQuery","query","_toBundledQuery","docs","elementToLengthPrefixedBuffer","bundleElement","buffer","Buffer","from","JSON","stringify","lengthBuffer","toString","concat","build","bundleBuffer","alloc","namedQuery","values","bundledDocument","documentMetadata","createTime","version","totalDocuments","size","totalBytes","BundledDocument","arg","DocumentSnapshot","invalidArgumentMessage","QuerySnapshot"],"mappings":"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","sourcesContent":["\"use strict\";\n// Copyright 2020 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst document_1 = require(\"./document\");\nconst reference_1 = require(\"./reference\");\nconst timestamp_1 = require(\"./timestamp\");\nconst validate_1 = require(\"./validate\");\nconst BUNDLE_VERSION = 1;\n/**\n * Builds a Firestore data bundle with results from the given document and query snapshots.\n *\n * @private\n */\nclass BundleBuilder {\n    constructor(bundleId) {\n        this.bundleId = bundleId;\n        // Resulting documents for the bundle, keyed by full document path.\n        this.documents = new Map();\n        // Named queries saved in the bundle, keyed by query name.\n        this.namedQueries = new Map();\n        // The latest read time among all bundled documents and queries.\n        this.latestReadTime = new timestamp_1.Timestamp(0, 0);\n    }\n    /**\n     * Adds a Firestore document snapshot or query snapshot to the bundle.\n     * Both the documents data and the query read time will be included in the bundle.\n     *\n     * @param {DocumentSnapshot | string} documentOrName A document snapshot to add or a name of a query.\n     * @param {Query=} querySnapshot A query snapshot to add to the bundle, if provided.\n     * @returns {BundleBuilder} This instance.\n     *\n     * @example\n     * const bundle = firestore.bundle('data-bundle');\n     * const docSnapshot = await firestore.doc('abc/123').get();\n     * const querySnapshot = await firestore.collection('coll').get();\n     *\n     * const bundleBuffer = bundle.add(docSnapshot); // Add a document\n     *                            .add('coll-query', querySnapshot) // Add a named query.\n     *                            .build()\n     * // Save `bundleBuffer` to CDN or stream it to clients.\n     */\n    add(documentOrName, querySnapshot) {\n        // eslint-disable-next-line prefer-rest-params\n        validate_1.validateMinNumberOfArguments('BundleBuilder.add', arguments, 1);\n        // eslint-disable-next-line prefer-rest-params\n        validate_1.validateMaxNumberOfArguments('BundleBuilder.add', arguments, 2);\n        if (arguments.length === 1) {\n            validateDocumentSnapshot('documentOrName', documentOrName);\n            this.addBundledDocument(documentOrName);\n        }\n        else {\n            validate_1.validateString('documentOrName', documentOrName);\n            validateQuerySnapshot('querySnapshot', querySnapshot);\n            this.addNamedQuery(documentOrName, querySnapshot);\n        }\n        return this;\n    }\n    addBundledDocument(snap) {\n        const docProto = snap.toDocumentProto();\n        this.documents.set(snap.id, {\n            document: snap.exists ? docProto : undefined,\n            metadata: {\n                name: docProto.name,\n                readTime: snap.readTime.toProto().timestampValue,\n                exists: snap.exists,\n            },\n        });\n        if (snap.readTime > this.latestReadTime) {\n            this.latestReadTime = snap.readTime;\n        }\n    }\n    addNamedQuery(name, querySnap) {\n        if (this.namedQueries.has(name)) {\n            throw new Error(`Query name conflict: ${name} is already added.`);\n        }\n        this.namedQueries.set(name, {\n            name,\n            bundledQuery: querySnap.query._toBundledQuery(),\n            readTime: querySnap.readTime.toProto().timestampValue,\n        });\n        for (const snap of querySnap.docs) {\n            this.addBundledDocument(snap);\n        }\n        if (querySnap.readTime > this.latestReadTime) {\n            this.latestReadTime = querySnap.readTime;\n        }\n    }\n    /**\n     * Converts a IBundleElement to a Buffer whose content is the length prefixed JSON representation\n     * of the element.\n     * @private\n     */\n    elementToLengthPrefixedBuffer(bundleElement) {\n        const buffer = Buffer.from(JSON.stringify(bundleElement), 'utf-8');\n        const lengthBuffer = Buffer.from(buffer.length.toString());\n        return Buffer.concat([lengthBuffer, buffer]);\n    }\n    build() {\n        let bundleBuffer = Buffer.alloc(0);\n        for (const namedQuery of this.namedQueries.values()) {\n            bundleBuffer = Buffer.concat([\n                bundleBuffer,\n                this.elementToLengthPrefixedBuffer({ namedQuery }),\n            ]);\n        }\n        for (const bundledDocument of this.documents.values()) {\n            const documentMetadata = bundledDocument.metadata;\n            bundleBuffer = Buffer.concat([\n                bundleBuffer,\n                this.elementToLengthPrefixedBuffer({ documentMetadata }),\n            ]);\n            // Write to the bundle if document exists.\n            const document = bundledDocument.document;\n            if (document) {\n                bundleBuffer = Buffer.concat([\n                    bundleBuffer,\n                    this.elementToLengthPrefixedBuffer({ document }),\n                ]);\n            }\n        }\n        const metadata = {\n            id: this.bundleId,\n            createTime: this.latestReadTime.toProto().timestampValue,\n            version: BUNDLE_VERSION,\n            totalDocuments: this.documents.size,\n            totalBytes: bundleBuffer.length,\n        };\n        // Prepends the metadata element to the bundleBuffer: `bundleBuffer` is the second argument to `Buffer.concat`.\n        bundleBuffer = Buffer.concat([\n            this.elementToLengthPrefixedBuffer({ metadata }),\n            bundleBuffer,\n        ]);\n        return bundleBuffer;\n    }\n}\nexports.BundleBuilder = BundleBuilder;\n/**\n * Convenient class to hold both the metadata and the actual content of a document to be bundled.\n * @private\n */\nclass BundledDocument {\n    constructor(metadata, document) {\n        this.metadata = metadata;\n        this.document = document;\n    }\n}\n/**\n * Validates that 'value' is DocumentSnapshot.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n */\nfunction validateDocumentSnapshot(arg, value) {\n    if (!(value instanceof document_1.DocumentSnapshot)) {\n        throw new Error(validate_1.invalidArgumentMessage(arg, 'DocumentSnapshot'));\n    }\n}\n/**\n * Validates that 'value' is QuerySnapshot.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n */\nfunction validateQuerySnapshot(arg, value) {\n    if (!(value instanceof reference_1.QuerySnapshot)) {\n        throw new Error(validate_1.invalidArgumentMessage(arg, 'QuerySnapshot'));\n    }\n}\n//# sourceMappingURL=bundle.js.map"]},"metadata":{},"sourceType":"script"}