{"ast":null,"code":"\"use strict\"; // Copyright 2020 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SigningError = exports.URLSigner = exports.PATH_STYLED_HOST = void 0;\n\nconst crypto = require(\"crypto\");\n\nconst dateFormat = require(\"date-and-time\");\n\nconst url = require(\"url\");\n\nconst util_1 = require(\"./util\");\n/*\n * Default signing version for getSignedUrl is 'v2'.\n */\n\n\nconst DEFAULT_SIGNING_VERSION = 'v2';\nconst SEVEN_DAYS = 604800;\n/**\n * @const {string}\n * @private\n */\n\nexports.PATH_STYLED_HOST = 'https://storage.googleapis.com';\n\nclass URLSigner {\n  constructor(authClient, bucket, file) {\n    this.bucket = bucket;\n    this.file = file;\n    this.authClient = authClient;\n  }\n\n  getSignedUrl(cfg) {\n    const expiresInSeconds = this.parseExpires(cfg.expires);\n    const method = cfg.method;\n    let customHost; // Default style is `path`.\n\n    const isVirtualHostedStyle = cfg.virtualHostedStyle || false;\n\n    if (cfg.cname) {\n      customHost = cfg.cname;\n    } else if (isVirtualHostedStyle) {\n      customHost = `https://${this.bucket.name}.storage.googleapis.com`;\n    }\n\n    const config = Object.assign({}, cfg, {\n      method,\n      expiration: expiresInSeconds,\n      bucket: this.bucket.name,\n      file: this.file ? util_1.encodeURI(this.file.name, false) : undefined\n    });\n\n    if (customHost) {\n      config.cname = customHost;\n    }\n\n    const version = cfg.version || DEFAULT_SIGNING_VERSION;\n    let promise;\n\n    if (version === 'v2') {\n      promise = this.getSignedUrlV2(config);\n    } else if (version === 'v4') {\n      promise = this.getSignedUrlV4(config);\n    } else {\n      throw new Error(`Invalid signed URL version: ${version}. Supported versions are 'v2' and 'v4'.`);\n    }\n\n    return promise.then(query => {\n      query = Object.assign(query, cfg.queryParams);\n      const signedUrl = new url.URL(config.cname || exports.PATH_STYLED_HOST);\n      signedUrl.pathname = this.getResourcePath(!!config.cname, this.bucket.name, config.file); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n      signedUrl.search = util_1.qsStringify(query);\n      return signedUrl.href;\n    });\n  }\n\n  getSignedUrlV2(config) {\n    const canonicalHeadersString = this.getCanonicalHeaders(config.extensionHeaders || {});\n    const resourcePath = this.getResourcePath(false, config.bucket, config.file);\n    const blobToSign = [config.method, config.contentMd5 || '', config.contentType || '', config.expiration, canonicalHeadersString + resourcePath].join('\\n');\n\n    const sign = async () => {\n      const authClient = this.authClient;\n\n      try {\n        const signature = await authClient.sign(blobToSign);\n        const credentials = await authClient.getCredentials();\n        return {\n          GoogleAccessId: credentials.client_email,\n          Expires: config.expiration,\n          Signature: signature\n        };\n      } catch (err) {\n        const signingErr = new SigningError(err.message);\n        signingErr.stack = err.stack;\n        throw signingErr;\n      }\n    };\n\n    return sign();\n  }\n\n  getSignedUrlV4(config) {\n    const now = new Date();\n    const nowInSeconds = Math.floor(now.valueOf() / 1000);\n    const expiresPeriodInSeconds = config.expiration - nowInSeconds; // v4 limit expiration to be 7 days maximum\n\n    if (expiresPeriodInSeconds > SEVEN_DAYS) {\n      throw new Error(`Max allowed expiration is seven days (${SEVEN_DAYS} seconds).`);\n    }\n\n    const extensionHeaders = Object.assign({}, config.extensionHeaders);\n    const fqdn = new url.URL(config.cname || exports.PATH_STYLED_HOST);\n    extensionHeaders.host = fqdn.host;\n\n    if (config.contentMd5) {\n      extensionHeaders['content-md5'] = config.contentMd5;\n    }\n\n    if (config.contentType) {\n      extensionHeaders['content-type'] = config.contentType;\n    }\n\n    let contentSha256;\n    const sha256Header = extensionHeaders['x-goog-content-sha256'];\n\n    if (sha256Header) {\n      if (typeof sha256Header !== 'string' || !/[A-Fa-f0-9]{40}/.test(sha256Header)) {\n        throw new Error('The header X-Goog-Content-SHA256 must be a hexadecimal string.');\n      }\n\n      contentSha256 = sha256Header;\n    }\n\n    const signedHeaders = Object.keys(extensionHeaders).map(header => header.toLowerCase()).sort().join(';');\n    const extensionHeadersString = this.getCanonicalHeaders(extensionHeaders);\n    const datestamp = dateFormat.format(now, 'YYYYMMDD', true);\n    const credentialScope = `${datestamp}/auto/storage/goog4_request`;\n\n    const sign = async () => {\n      const credentials = await this.authClient.getCredentials();\n      const credential = `${credentials.client_email}/${credentialScope}`;\n      const dateISO = dateFormat.format(now, 'YYYYMMDD[T]HHmmss[Z]', true);\n      const queryParams = {\n        'X-Goog-Algorithm': 'GOOG4-RSA-SHA256',\n        'X-Goog-Credential': credential,\n        'X-Goog-Date': dateISO,\n        'X-Goog-Expires': expiresPeriodInSeconds.toString(10),\n        'X-Goog-SignedHeaders': signedHeaders,\n        ...(config.queryParams || {})\n      }; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n      const canonicalQueryParams = this.getCanonicalQueryParams(queryParams);\n      const canonicalRequest = this.getCanonicalRequest(config.method, this.getResourcePath(!!config.cname, config.bucket, config.file), canonicalQueryParams, extensionHeadersString, signedHeaders, contentSha256);\n      const hash = crypto.createHash('sha256').update(canonicalRequest).digest('hex');\n      const blobToSign = ['GOOG4-RSA-SHA256', dateISO, credentialScope, hash].join('\\n');\n\n      try {\n        const signature = await this.authClient.sign(blobToSign);\n        const signatureHex = Buffer.from(signature, 'base64').toString('hex');\n        const signedQuery = Object.assign({}, queryParams, {\n          'X-Goog-Signature': signatureHex\n        });\n        return signedQuery;\n      } catch (err) {\n        const signingErr = new SigningError(err.message);\n        signingErr.stack = err.stack;\n        throw signingErr;\n      }\n    };\n\n    return sign();\n  }\n  /**\n   * Create canonical headers for signing v4 url.\n   *\n   * The canonical headers for v4-signing a request demands header names are\n   * first lowercased, followed by sorting the header names.\n   * Then, construct the canonical headers part of the request:\n   *  <lowercasedHeaderName> + \":\" + Trim(<value>) + \"\\n\"\n   *  ..\n   *  <lowercasedHeaderName> + \":\" + Trim(<value>) + \"\\n\"\n   *\n   * @param headers\n   * @private\n   */\n\n\n  getCanonicalHeaders(headers) {\n    // Sort headers by their lowercased names\n    const sortedHeaders = util_1.objectEntries(headers) // Convert header names to lowercase\n    .map(([headerName, value]) => [headerName.toLowerCase(), value]).sort((a, b) => a[0].localeCompare(b[0]));\n    return sortedHeaders.filter(([, value]) => value !== undefined).map(([headerName, value]) => {\n      // - Convert Array (multi-valued header) into string, delimited by\n      //      ',' (no space).\n      // - Trim leading and trailing spaces.\n      // - Convert sequential (2+) spaces into a single space\n      const canonicalValue = `${value}`.trim().replace(/\\s{2,}/g, ' ');\n      return `${headerName}:${canonicalValue}\\n`;\n    }).join('');\n  }\n\n  getCanonicalRequest(method, path, query, headers, signedHeaders, contentSha256) {\n    return [method, path, query, headers, signedHeaders, contentSha256 || 'UNSIGNED-PAYLOAD'].join('\\n');\n  }\n\n  getCanonicalQueryParams(query) {\n    return util_1.objectEntries(query).map(([key, value]) => [util_1.encodeURI(key, true), util_1.encodeURI(value, true)]).sort((a, b) => a[0] < b[0] ? -1 : 1).map(([key, value]) => `${key}=${value}`).join('&');\n  }\n\n  getResourcePath(cname, bucket, file) {\n    if (cname) {\n      return '/' + (file || '');\n    } else if (file) {\n      return `/${bucket}/${file}`;\n    } else {\n      return `/${bucket}`;\n    }\n  }\n\n  parseExpires(expires, current = new Date()) {\n    const expiresInMSeconds = new Date(expires).valueOf();\n\n    if (isNaN(expiresInMSeconds)) {\n      throw new Error('The expiration date provided was invalid.');\n    }\n\n    if (expiresInMSeconds < current.valueOf()) {\n      throw new Error('An expiration date cannot be in the past.');\n    }\n\n    return Math.round(expiresInMSeconds / 1000); // The API expects seconds.\n  }\n\n}\n\nexports.URLSigner = URLSigner;\n/**\n * Custom error type for errors related to getting signed errors and policies.\n *\n * @private\n */\n\nclass SigningError extends Error {\n  constructor() {\n    super(...arguments);\n    this.name = 'SigningError';\n  }\n\n}\n\nexports.SigningError = SigningError;","map":{"version":3,"sources":["C:/React/slacker/node_modules/@google-cloud/storage/build/src/signer.js"],"names":["Object","defineProperty","exports","value","SigningError","URLSigner","PATH_STYLED_HOST","crypto","require","dateFormat","url","util_1","DEFAULT_SIGNING_VERSION","SEVEN_DAYS","constructor","authClient","bucket","file","getSignedUrl","cfg","expiresInSeconds","parseExpires","expires","method","customHost","isVirtualHostedStyle","virtualHostedStyle","cname","name","config","assign","expiration","encodeURI","undefined","version","promise","getSignedUrlV2","getSignedUrlV4","Error","then","query","queryParams","signedUrl","URL","pathname","getResourcePath","search","qsStringify","href","canonicalHeadersString","getCanonicalHeaders","extensionHeaders","resourcePath","blobToSign","contentMd5","contentType","join","sign","signature","credentials","getCredentials","GoogleAccessId","client_email","Expires","Signature","err","signingErr","message","stack","now","Date","nowInSeconds","Math","floor","valueOf","expiresPeriodInSeconds","fqdn","host","contentSha256","sha256Header","test","signedHeaders","keys","map","header","toLowerCase","sort","extensionHeadersString","datestamp","format","credentialScope","credential","dateISO","toString","canonicalQueryParams","getCanonicalQueryParams","canonicalRequest","getCanonicalRequest","hash","createHash","update","digest","signatureHex","Buffer","from","signedQuery","headers","sortedHeaders","objectEntries","headerName","a","b","localeCompare","filter","canonicalValue","trim","replace","path","key","current","expiresInMSeconds","isNaN","round","arguments"],"mappings":"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","sourcesContent":["\"use strict\";\n// Copyright 2020 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SigningError = exports.URLSigner = exports.PATH_STYLED_HOST = void 0;\nconst crypto = require(\"crypto\");\nconst dateFormat = require(\"date-and-time\");\nconst url = require(\"url\");\nconst util_1 = require(\"./util\");\n/*\n * Default signing version for getSignedUrl is 'v2'.\n */\nconst DEFAULT_SIGNING_VERSION = 'v2';\nconst SEVEN_DAYS = 604800;\n/**\n * @const {string}\n * @private\n */\nexports.PATH_STYLED_HOST = 'https://storage.googleapis.com';\nclass URLSigner {\n    constructor(authClient, bucket, file) {\n        this.bucket = bucket;\n        this.file = file;\n        this.authClient = authClient;\n    }\n    getSignedUrl(cfg) {\n        const expiresInSeconds = this.parseExpires(cfg.expires);\n        const method = cfg.method;\n        let customHost;\n        // Default style is `path`.\n        const isVirtualHostedStyle = cfg.virtualHostedStyle || false;\n        if (cfg.cname) {\n            customHost = cfg.cname;\n        }\n        else if (isVirtualHostedStyle) {\n            customHost = `https://${this.bucket.name}.storage.googleapis.com`;\n        }\n        const config = Object.assign({}, cfg, {\n            method,\n            expiration: expiresInSeconds,\n            bucket: this.bucket.name,\n            file: this.file ? util_1.encodeURI(this.file.name, false) : undefined,\n        });\n        if (customHost) {\n            config.cname = customHost;\n        }\n        const version = cfg.version || DEFAULT_SIGNING_VERSION;\n        let promise;\n        if (version === 'v2') {\n            promise = this.getSignedUrlV2(config);\n        }\n        else if (version === 'v4') {\n            promise = this.getSignedUrlV4(config);\n        }\n        else {\n            throw new Error(`Invalid signed URL version: ${version}. Supported versions are 'v2' and 'v4'.`);\n        }\n        return promise.then(query => {\n            query = Object.assign(query, cfg.queryParams);\n            const signedUrl = new url.URL(config.cname || exports.PATH_STYLED_HOST);\n            signedUrl.pathname = this.getResourcePath(!!config.cname, this.bucket.name, config.file);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            signedUrl.search = util_1.qsStringify(query);\n            return signedUrl.href;\n        });\n    }\n    getSignedUrlV2(config) {\n        const canonicalHeadersString = this.getCanonicalHeaders(config.extensionHeaders || {});\n        const resourcePath = this.getResourcePath(false, config.bucket, config.file);\n        const blobToSign = [\n            config.method,\n            config.contentMd5 || '',\n            config.contentType || '',\n            config.expiration,\n            canonicalHeadersString + resourcePath,\n        ].join('\\n');\n        const sign = async () => {\n            const authClient = this.authClient;\n            try {\n                const signature = await authClient.sign(blobToSign);\n                const credentials = await authClient.getCredentials();\n                return {\n                    GoogleAccessId: credentials.client_email,\n                    Expires: config.expiration,\n                    Signature: signature,\n                };\n            }\n            catch (err) {\n                const signingErr = new SigningError(err.message);\n                signingErr.stack = err.stack;\n                throw signingErr;\n            }\n        };\n        return sign();\n    }\n    getSignedUrlV4(config) {\n        const now = new Date();\n        const nowInSeconds = Math.floor(now.valueOf() / 1000);\n        const expiresPeriodInSeconds = config.expiration - nowInSeconds;\n        // v4 limit expiration to be 7 days maximum\n        if (expiresPeriodInSeconds > SEVEN_DAYS) {\n            throw new Error(`Max allowed expiration is seven days (${SEVEN_DAYS} seconds).`);\n        }\n        const extensionHeaders = Object.assign({}, config.extensionHeaders);\n        const fqdn = new url.URL(config.cname || exports.PATH_STYLED_HOST);\n        extensionHeaders.host = fqdn.host;\n        if (config.contentMd5) {\n            extensionHeaders['content-md5'] = config.contentMd5;\n        }\n        if (config.contentType) {\n            extensionHeaders['content-type'] = config.contentType;\n        }\n        let contentSha256;\n        const sha256Header = extensionHeaders['x-goog-content-sha256'];\n        if (sha256Header) {\n            if (typeof sha256Header !== 'string' ||\n                !/[A-Fa-f0-9]{40}/.test(sha256Header)) {\n                throw new Error('The header X-Goog-Content-SHA256 must be a hexadecimal string.');\n            }\n            contentSha256 = sha256Header;\n        }\n        const signedHeaders = Object.keys(extensionHeaders)\n            .map(header => header.toLowerCase())\n            .sort()\n            .join(';');\n        const extensionHeadersString = this.getCanonicalHeaders(extensionHeaders);\n        const datestamp = dateFormat.format(now, 'YYYYMMDD', true);\n        const credentialScope = `${datestamp}/auto/storage/goog4_request`;\n        const sign = async () => {\n            const credentials = await this.authClient.getCredentials();\n            const credential = `${credentials.client_email}/${credentialScope}`;\n            const dateISO = dateFormat.format(now, 'YYYYMMDD[T]HHmmss[Z]', true);\n            const queryParams = {\n                'X-Goog-Algorithm': 'GOOG4-RSA-SHA256',\n                'X-Goog-Credential': credential,\n                'X-Goog-Date': dateISO,\n                'X-Goog-Expires': expiresPeriodInSeconds.toString(10),\n                'X-Goog-SignedHeaders': signedHeaders,\n                ...(config.queryParams || {}),\n            };\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const canonicalQueryParams = this.getCanonicalQueryParams(queryParams);\n            const canonicalRequest = this.getCanonicalRequest(config.method, this.getResourcePath(!!config.cname, config.bucket, config.file), canonicalQueryParams, extensionHeadersString, signedHeaders, contentSha256);\n            const hash = crypto\n                .createHash('sha256')\n                .update(canonicalRequest)\n                .digest('hex');\n            const blobToSign = [\n                'GOOG4-RSA-SHA256',\n                dateISO,\n                credentialScope,\n                hash,\n            ].join('\\n');\n            try {\n                const signature = await this.authClient.sign(blobToSign);\n                const signatureHex = Buffer.from(signature, 'base64').toString('hex');\n                const signedQuery = Object.assign({}, queryParams, {\n                    'X-Goog-Signature': signatureHex,\n                });\n                return signedQuery;\n            }\n            catch (err) {\n                const signingErr = new SigningError(err.message);\n                signingErr.stack = err.stack;\n                throw signingErr;\n            }\n        };\n        return sign();\n    }\n    /**\n     * Create canonical headers for signing v4 url.\n     *\n     * The canonical headers for v4-signing a request demands header names are\n     * first lowercased, followed by sorting the header names.\n     * Then, construct the canonical headers part of the request:\n     *  <lowercasedHeaderName> + \":\" + Trim(<value>) + \"\\n\"\n     *  ..\n     *  <lowercasedHeaderName> + \":\" + Trim(<value>) + \"\\n\"\n     *\n     * @param headers\n     * @private\n     */\n    getCanonicalHeaders(headers) {\n        // Sort headers by their lowercased names\n        const sortedHeaders = util_1.objectEntries(headers)\n            // Convert header names to lowercase\n            .map(([headerName, value]) => [\n            headerName.toLowerCase(),\n            value,\n        ])\n            .sort((a, b) => a[0].localeCompare(b[0]));\n        return sortedHeaders\n            .filter(([, value]) => value !== undefined)\n            .map(([headerName, value]) => {\n            // - Convert Array (multi-valued header) into string, delimited by\n            //      ',' (no space).\n            // - Trim leading and trailing spaces.\n            // - Convert sequential (2+) spaces into a single space\n            const canonicalValue = `${value}`.trim().replace(/\\s{2,}/g, ' ');\n            return `${headerName}:${canonicalValue}\\n`;\n        })\n            .join('');\n    }\n    getCanonicalRequest(method, path, query, headers, signedHeaders, contentSha256) {\n        return [\n            method,\n            path,\n            query,\n            headers,\n            signedHeaders,\n            contentSha256 || 'UNSIGNED-PAYLOAD',\n        ].join('\\n');\n    }\n    getCanonicalQueryParams(query) {\n        return util_1.objectEntries(query)\n            .map(([key, value]) => [util_1.encodeURI(key, true), util_1.encodeURI(value, true)])\n            .sort((a, b) => (a[0] < b[0] ? -1 : 1))\n            .map(([key, value]) => `${key}=${value}`)\n            .join('&');\n    }\n    getResourcePath(cname, bucket, file) {\n        if (cname) {\n            return '/' + (file || '');\n        }\n        else if (file) {\n            return `/${bucket}/${file}`;\n        }\n        else {\n            return `/${bucket}`;\n        }\n    }\n    parseExpires(expires, current = new Date()) {\n        const expiresInMSeconds = new Date(expires).valueOf();\n        if (isNaN(expiresInMSeconds)) {\n            throw new Error('The expiration date provided was invalid.');\n        }\n        if (expiresInMSeconds < current.valueOf()) {\n            throw new Error('An expiration date cannot be in the past.');\n        }\n        return Math.round(expiresInMSeconds / 1000); // The API expects seconds.\n    }\n}\nexports.URLSigner = URLSigner;\n/**\n * Custom error type for errors related to getting signed errors and policies.\n *\n * @private\n */\nclass SigningError extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = 'SigningError';\n    }\n}\nexports.SigningError = SigningError;\n//# sourceMappingURL=signer.js.map"]},"metadata":{},"sourceType":"script"}